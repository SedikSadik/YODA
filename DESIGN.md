# YODA DESIGN DOCUMENT
## Process 
At the beginning of this project, this was just a cool idea I wanted to do. Yet, I didn't know so many things. 
* We had done user inputs where the input was text or a boolean value. How could I accept a user's _uplaod files_? 
* How could I ensure that the uploaded file was valid file? What if the user had uploaded a `txt` file instead of, say, a `png` file?
* How could I run object detection on an image. What about a video? God forbid what I would do with a live stream of images. 
* How would I store the files uploaded by the user? What would happen if a user uploaded a file that had already been uploaded?

I broke down what I needed to do into chunks and worked on each chunk seperately. 
I found youtube videos, stack overflow posts, and blogs which were very helpful in me solving my problems. 
I will go into detail into the `app.py`, `app.js`, `helpers.py` and each of the html templates I created and explained why I decided to implement it the way I did. 

## Things learned
Before a deep dive into each individual file, I want to list all the things I used and learned through this project. 
These include:
* Using a virtual environment
* File authentication and saving with flask, wtforms
* Serving files with `send_from_directory`
* P5.js for the live webcam tab.
* Lots of bootstrap
* SQL databases
* reading a video file
* writing a video file using `cv2.VideoWriter`
* Different video codec
* Running object detection and using the results
* drawing on existing image frames
* Using hidden input tags in forms to send secret information to the server. 
* And many more...

## Deep Dive

### `app.py`
I first needed to decide how to store user files and ultimately decided on saving files in the file storage instead of the sql database. 
I decided on having two folders, `uploads` and `detected` and then two more folders in each of those, one for images and one for videos. 
I didn't want to reliant on those folders existing, so I coded something on top of the file to check if those folders exist and, if they don't exist, create them.

I decided to use the YOLOv4 object model because it is very fast even in weaker computers. It also has  a high accuracy for its size. I decided to use the model trained on the ms-coco dataset. 

For serving files, I decided to create just one function `get_files` that would serve all four important file locations. To do this, it uses input from the user to know which folder it needs to look in. Whenever I use `url_for`, then, I pass in which process type (upload of detection), which media type (images or videos), which user it belongs to and the filename. Apparently `send_from_directory` wants the filename to be compeltely separate from the directory it is being placed in, so I join the first three things and pass in filename seperately. 

I notice when testing several images that some obvious objects weren't being detected, so I set the `confidence_threshold` to be 0.4. 

Since the other functions correspond to different website tabs, I will explain those functions in the corresponding tabs' explanation

### `index.html`
Since I chose the name to be YODA, I decided to put some explanations of what the different tabs to but in a way yoda would have said it. Since I haven't watched star wars, I don't know if I succeeded :D

Other than that it is a pretty standard html with bootstrap cards user to give some structure. 

### `image_detection.html`
I learned how to create a form in python and then pass it into the jinja template which helped a lot with accepting user file input and validating them. I used the predefined `IMAGES` variable to define what extensions are allowed. 

In the serving function I first validate a form when it is passed in using the `validate_on_submit` button. Then I save the file in the relevant folder and read it as an image matrix. opencv provides a nice abstraction run object detection using `model.detect`. I use the response generated by that to draw boxes on the image. 

I record info on the uploaded and processed files and then send the url's of those files to the template with a little description. 

In the template side, I used a card container to show both photos. I decided to have a fixed width for the cards to that it doesn't look weird when uploading images of different sizes. 

### `video_detection.html`

Much of the function is actually similar to the image detection function. There are however some crutial differences. 

Due to a codec issue (i don't know if it is because of my computer or because of opencv), I am only able to output a video in `.mov` format. I can accept almost all video formats though, so it is not big problem. 

Because I am working with a video this time, I am looping through each frame of the video and running detection on each image seperately. 

I used the `cv2.VideoWriter` to write the files. 

I wasn't able to display the video in html for some reason. Although I was able to display the uploaded version, I wasn't able to do so with the processed video. Worse of all, I have no idea why it is not working. 

### `live_webcam.html`

I did find a way of using the `Response` class in flask to have a continuous stream to the webpage, but ultimately decided to use javascript and ml5 to do object detection for the webcam. It is a slightly different model, but still trained on the ms-coco dataset. 

using p5.js, I was able to create a canvas on which the live feed would be displayed. Each frame, the `draw` function in `app.js` is called and it displays the current webcam frame. Then the labels and bounding boxes are drawn. 

I added a button to the html side that would allow toggling on and off of the detection. I also added a save button which saves the current contents of the canvas as an image. 

### `saved_files.html`
I created a database with two tables. One for authentication of users using username and hash and other for saving informating (including path) about files.

When someone visits this route, I search through the database for files which belong to the user. Then I return that list of dictionaries to the template so each element (meaning a file) can be displayed on its own site. 

When displaying each file, I also put in the id of the file in my database. When the user clicks delete, the form returns the id of the file that the user wants to delete. Then I find that id and the corresponding filepath in the database. I delete the file and remove the database entry.  

I found a cool jquery script on tables that turn the table into a searchable and sortable table which is super helpful for a file system because we can search for a specific filename or even a date. I linked those scripts to the `saved_files.html` header. In the main portion, I decided to display four pieces of information for each file and also added functionality for the user to be able to download their files and/or delete them.  